#!/bin/sh

# SUSv3 compliant sed tests.
# Copyright 2005 by Rob Landley <rob@landley.net>
# Licensed under GPL v2, see file LICENSE for details.

[ -z "$COMMAND" ] && COMMAND=sed
. testing.sh

# testing "description" "arguments" "result" "infile" "stdin"

# Corner cases
testing "sed no files (stdin)" '""' "hello\n" "" "hello\n"
testing "sed explicit stdin" '"" -' "hello\n" "" "hello\n"
testing "sed handles empty lines" "-e 's/\$/@/'" "@\n" "" "\n"
testing "sed stdin twice" '"" - -' "hello" "" "hello"

# Trailing EOF.
#	Match $, at end of each file or all files?

# -e corner cases
#	without -e
#	multiple -e
#		interact with a
#	-eee arg1 arg2 arg3
# -f corner cases
#	-e -f -e
# -n corner cases
#	no newline at EOF?
# -r corner cases
#	Just make sure it works.
# -i corner cases:
#	sed -i -
#	permissions
#	-i on a symlink
#	on a directory
#       With $ last-line test
# Continue with \
#       End of script with trailing \

# command list
testing "sed accepts blanks before command" "-e '1 d'" "" "" ""
testing "sed accepts newlines in -e" "-e 'i\
1
a\
3'" "1\n2\n3\n" "" "2\n"
testing "sed accepts multiple -e" "-e 'i\' -e '1' -e 'a\' -e '3'" \
	"1\n2\n3\n" "" "2\n"

# substitutions
testing "sed -n" "-n -e s/foo/bar/ -e s/bar/baz/" "" "" "foo\n"
testing "sed s//p" "-e s/foo/bar/p -e s/bar/baz/p" "bar\nbaz\nbaz\n" \
	"" "foo\n"
testing "sed -n s//p" "-ne s/abc/def/p" "def\n" "" "abc\n"
testing "sed s//g (exhaustive)" "-e 's/[[:space:]]*/,/g'" ",1,2,3,4,5,\n" \
	"" "12345\n"
testing "sed s arbitrary delimiter" "-e 's woo boing '" "boing\n" "" "woo\n"
testing "sed s chains" "-e s/foo/bar/ -e s/bar/baz/" "baz\n" "" "foo\n"
testing "sed s chains2" "-e s/foo/bar/ -e s/baz/nee/" "bar\n" "" "foo\n"
testing "sed s [delimiter]" "-e 's@[@]@@'" "onetwo" "" "one@two"

# branch
testing "sed b (branch)" "-e 'b one;p;: one'" "foo\n" "" "foo\n"
testing "sed b (branch with no label jumps to end)" "-e 'b;p'" \
	"foo\n" "" "foo\n"

# test and branch
testing "sed t (test/branch)" "-e 's/a/1/;t one;p;: one;p'" \
	"1\n1\nb\nb\nb\nc\nc\nc\n" "" "a\nb\nc\n"
testing "sed t (test/branch clears test bit)" "-e 's/a/b/;:loop;t loop'" \
	"b\nb\nc\n" "" "a\nb\nc\n"
testing "sed T (!test/branch)" "-e 's/a/1/;T notone;p;: notone;p'" \
	"1\n1\n1\nb\nb\nc\nc\n" "" "a\nb\nc\n"

# Normal sed end-of-script doesn't print "c" because n flushed the pattern
# space.  If n hits EOF, pattern space is empty when script ends.
# Query: how does this interact with no newline at EOF?
testing "sed n (flushes pattern space, terminates early)" "-e 'n;p'" \
	"a\nb\nb\nc\n" "" "a\nb\nc\n"
# N does _not_ flush pattern space, therefore c is still in there @ script end.
testing "sed N (doesn't flush pattern space when terminating)" "-e 'N;p'" \
	"a\nb\na\nb\nc\n" "" "a\nb\nc\n"
testing "sed address match newline" '"/b/N;/b\\nc/i woo"' "a\nwoo\nb\nc\nd\n" \
	"" "a\nb\nc\nd\n"

# Multiple lines in pattern space
testing "sed N (stops at end of input) and P (prints to first newline only)" \
	"-n 'N;P;p'" "a\na\nb\n" "" "a\nb\nc\n"

# Hold space
testing "sed G (append hold space to pattern space)" 'G' "a\n\nb\n\nc\n\n" \
	"" "a\nb\nc\n"
#testing "sed g/G (swap/append hold and patter space)"
#testing "sed g (swap hold/pattern space)"

testing "sed d ends script iteration" \
	"-e '/ook/d;s/ook/ping/p;i woot'" "" "" "ook\n"
testing "sed d ends script iteration (2)" \
	"-e '/ook/d;a\' -e 'bang'" "woot\nbang\n" "" "ook\nwoot\n"

# Multiple files, with varying newlines and NUL bytes
testing "sed embedded NUL" "-e 's/woo/bang/'" "\0bang\0woo\0" "" "\0woo\0woo\0"
testing "sed embedded NUL g" "-e 's/woo/bang/g'" "bang\0bang\0" "" "woo\0woo\0"
echo -e "/woo/a he\0llo" > sed.commands
testing "sed NUL in command" "-f sed.commands" "woo\nhe\0llo\n" "" "woo"
rm sed.commands

# sed has funky behavior with newlines at the end of file.  Test lots of
# corner cases with the optional newline appending behavior.

testing "sed normal newlines" "-e 's/woo/bang/' input -" "bang\nbang\n" \
	"woo\n" "woo\n"
testing "sed leave off trailing newline" "-e 's/woo/bang/' input -" \
	"bang\nbang" "woo\n" "woo"
testing "sed autoinsert newline" "-e 's/woo/bang/' input -" "bang\nbang" \
	"woo" "woo"
testing "sed empty file plus cat" "-e 's/nohit//' input -" "one\ntwo" \
	"" "one\ntwo" 
testing "sed cat plus empty file" "-e 's/nohit//' input -" "one\ntwo" \
	"one\ntwo" ""
testing "sed append autoinserts newline" "-e '/woot/a woo' -" "woot\nwoo\n" \
	"" "woot"
testing "sed insert doesn't autoinsert newline" "-e '/woot/i woo' -" \
	"woo\nwoot" "" "woot"
testing "sed print autoinsert newlines" "-e 'p' -" "one\none" "" "one"
testing "sed print autoinsert newlines two files" "-e 'p' input -" \
	"one\none\ntwo\ntwo" "one" "two"
testing "sed noprint, no match, no newline" "-ne 's/woo/bang/' input" \
	"" "no\n" ""
testing "sed selective matches with one nl" "-ne 's/woo/bang/p' input -" \
	"a bang\nc bang\n" "a woo\nb no" "c woo\nd no"
testing "sed selective matches insert newline" "-ne 's/woo/bang/p' input -" \
	"a bang\nb bang\nd bang" "a woo\nb woo" "c no\nd woo"
testing "sed selective matches noinsert newline" "-ne 's/woo/bang/p' input -" \
	"a bang\nb bang" "a woo\nb woo" "c no\nd no"
testing "sed clusternewline" "-e '/one/a 111' -e '/two/i 222' -e p input -" \
	"one\none\n111\n222\ntwo\ntwo" "one" "two" 

# Test end-of-file matching behavior

testing "sed match EOF" " -e '"'$p'"'" "hello\nthere\nthere" "" "hello\nthere"
testing "sed match EOF two files" " -e '"'$p'"' input -" \
	"one\ntwo\nthree\nfour\nfour" "one\ntwo" "three\nfour"
echo -ne "three\nfour" > input2
testing "sed match EOF inline" \
	" -e '"'$i ook'"' -i input input2 && cat input input2" \
	"one\nook\ntwothree\nook\nfour" "one\ntwo" ""
rm input2

# Test lie-to-autoconf

testing "sed lie-to-autoconf" "--version | grep -o 'GNU sed version '" \
	"GNU sed version \n" "" ""

# Jump to nonexistent label
testing "sed nonexistent label" "-e 'b walrus' 2> /dev/null || echo yes" \
	"yes\n" "" ""

testing "sed backref from empty s uses range regex" \
	"-e '/woot/s//eep \0 eep/'" "eep woot eep" "" "woot"

testing "sed backref from empty s uses range regex with newline" \
	"-e '/woot/s//eep \0 eep/'" "eep woot eep\n" "" "woot\n"

# -i with no filename

touch ./-  # Detect gnu failure mode here.
testing "sed -i with no arg [GNUFAIL]" "-e '' -i 2> /dev/null || echo yes" \
	"yes\n" "" ""
rm ./-     # Clean up

# Ponder this a bit more, why "woo not found" from gnu version?
#testing "sed doesn't substitute in deleted line" \
#	"-e '/ook/d;s/ook//;t woo;a bang;'" "bang" "" "ook\n"

# This makes both seds very unhappy.  Why?
#testing "sed -g (exhaustive)" "sed -e 's/[[:space:]]*/,/g'" ",1,2,3,4,5," \
#	"" "12345"

exit $FAILCOUNT

Busybox TODO

Stuff that needs to be done

tr - missing SuS3 features in busybox 1.0pre10

tr doesnt support [:blank:], [:digit:] or other predefined classes, [=equiv=]
support is also missing.
----
find
  doesn't understand () or -exec, and these are actually used out in the real
  world.  The "make uninstall" of lots of things (including busybox itself)
  breaks because of this, and sometimes even "make install" (like udev).
----
sh
  The command shell situation is a big mess.  We have three or four different
  shells that don't really share any code, and the "standalone shell" doesn't
  work all that well (especially not in a chroot environment), due to apps not
  being reentrant.  Unifying the various shells and figuring out a configurable
  way of adding the minimal set of bash features a given script uses is a big
  job, but it be a big improvement.

  Note: Rob Landley (rob@landley.net) is working on this one, but very slowly...
---
gzip
  Can't handle compressing multiple files at once.  (I don't mean making a
  multiple file archive, I mean compressing more than one file at a time.)
  Some global variables aren't re-initialized between runs.
---
gunzip
  same problem as gzip.  "gunzip one.gz two.gz three.gz" doesn't work for
  two.gz and three.gz due to global variables not getting reset.
---
diff
  We should have a diff -u command.  We have patch, we should have diff
  (we only need to support unified diffs though).
---
fuser
  Would be nice.  The basic susv3 options, plus fuser -k.
---
patch
  should have simple fuzz factor support to apply patches at an offset which
  shouldn't take up too much space.
---
man
  It would be nice to have a man command.  Not one that handles troff or
  anything, just one that can handle preformatted ascii man pages, possibly
  compressed.  This could probably be a script in the extras directory that
  calls cat/zcatbzcat | more
---
bzip2
  Compression-side support.


Architectural issues:

Do a SUSv3 audit
  Look at the full Single Unix Specification version 3 (available online at
  "http://www.opengroup.org/onlinepubs/009695399/nfindex.html") and
  figure out which of our apps are compliant, and what we're missing that
  we might actually care about.

  Even better would be some kind of automated compliance test harness that
  exercises each command line option and the various corner cases.
--
Unify archivers
  Lots of archivers have the same general infrastructure.  The directory
  traversal code should be factored out, and the guts of each archiver could
  be some setup code and a series of callbacks for "add this file",
  "add this directory", "add this symlink" and so on.

  This could clean up tar and zip, and make it cheaper to add cpio and ar
  write support, and possibly even cheaply add things like mkisofs someday,
  if it becomes relevant.
---
Text buffer support.
  Several existing applets and potential additions (sort, vi, less...) read
  a whole file into memory and act on it.  There might be an opportunity
  for shared code in there that could be moved into libbb...
---
Individual compilation of applets.
  It would be nice if busybox had the option to compile to individual applets,
  for people who want an alternate implementation less bloated than the gnu
  utils (or simply with less political baggage), but without it being one big
  executable.

  Turning libbb into a real dll is another possibility, especially if libbb
  could export some of the other library interfaces we've already more or less
  got the code for (like zlib).
---
buildroot - Make a "dogfood" option
  Busybox is now capable of replacing most gnu packages for real world use,
  such as developing software or in a live CD.  A system built from busybox
  (1.00 with updated sort.c), uclibc 0.9.27, gcc, binutils, make, and a few
  other development tools (http://www.landley.net/code/firmware has an example
  system using autoconf, automake, bison, flex, libtools, m4, zlib,
  and groff: dunno what subset of that is actually necessary) is capable of
  rebuilding itself, from scratch, under itself.

  It would be a good "eating our own dogfood" test if buildroot had the option
  of using busybox instead of bzip2, coreutils, file, findutils, gawk, grep,
  inetutils, modutils, net-tools, procps, sed, shadow, sysklogd, sysvinit, tar,
  util-linux, and vim.  Anything that's wrong with the resulting system, we
  can fix.  (It would be nice to be able to upgrade busybox to be able to
  replace bash, diffutils, gzip, less, and patch as well.)
---
Memory Allocation
  We have a CONFIG_BUFFER mechanism that lets us select whether to do memory
  allocation on the stack or the heap.  Unfortunately, we're not using it much.
  We need to audit our memory allocations and turn a lot of malloc/free calls
  into RESERVE_CONFIG_BUFFER/RELEASE_CONFIG_BUFFER.

  And while we're at it, many of the CONFIG_FEATURE_CLEAN_UP #ifdefs will be
  optimized out by the compiler in the stack allocation case (since there's no
  free for an alloca()), and this means that various cleanup loops that just
  call free might also be optimized out by the compiler if written right, so
  we can yank those #ifdefs too, and generally clean up the code.
---
Switch CONFIG_SYMBOLS to ENABLE_SYMBOLS

  In busybox 1.0 and earlier, configuration was done by CONFIG_SYMBOLS
  that were either defined or undefined to indicate whether the symbol was
  selected in the .config file.  They were used with #ifdefs, ala:

    #ifdef CONFIG_SYMBOL
      if (other_test) {
        do_code();
      }
    #endif

  In 1.1, we have new ENABLE_SYMBOLS which are always defined (as 0 or 1),
  meaning you can still use them for preprocessor tests by replacing
  "#ifdef CONFIG_SYMBOL" with "#if ENABLE_SYMBOL".  But more importantly, we
  can use them as a true or false test in normal C code:

    if (ENABLE_SYMBOL && other_test) {
      do_code();
    }

  (Optimizing away if() statements that resolve to a constant value
  is known as "dead code elimination", an optimization so old and simple that
  Turbo Pascal for DOS did it twenty years ago.  Even modern mini-compilers
  like the Tiny C Compiler (tcc) and the Small Device C Compiler (SDCC)
  perform dead code elimination.)

  Right now, busybox.h is #including both "config.h" (defining the
  CONFIG_SYMBOLS) and "bb_config.h" (defining the ENABLE_SYMBOLS).  At some
  point in the future, it would be nice to wean ourselves off of the
  CONFIG versions.  (Among other things, some defective build environments
  leak the Linux kernel's CONFIG_SYMBOLS into the system's standard #include
  files.  We've experienced collisions before.)
---
FEATURE_CLEAN_UP
  This is more an unresolved issue than a to-do item.  More thought is needed.

  Normally we rely on exit() to free memory, close files, and unmap segments
  for us.  This makes most calls to free(), close(), and unmap() optional in
  busybox applets that don't intend to run for very long, and optional stuff
  can be omitted to save size.

  The idea was raised that we could simulate fork/exit with setjmp/longjmp
  for _really_ brainless embedded systems, or speed up the standalone shell
  by not forking.  Doing so would require a reliable FEATURE_CLEAN_UP.
  Unfortunately, this isn't as easy as it sounds.

  The problem is, lots of things exit(), sometimes unexpectedly (xmalloc())
  and sometimes reliably (bb_perror_msg_and_die() or show_usage()).  This
  jumps out of the normal flow control and bypasses any cleanup code we
  put at the end of our applets.

  It's possible to add hooks to libbb functions like xmalloc() and bb_xopen()
  to add their entries to a linked list, which could be traversed and
  freed/closed automatically.  (This would need to be able to free just the
  entries after a checkpoint to be usable for a forkless standalone shell.
  You don't want to free the shell's own resources.)

  Right now, FEATURE_CLEAN_UP is more or less a debugging aid, to make things
  like valgrind happy.  It's also documentation of _what_ we're trusting
  exit() to clean up for us.  But new infrastructure to auto-free stuff would
  render the existing FEATURE_CLEAN_UP code redundant.

  For right now, exit() handles it just fine.
